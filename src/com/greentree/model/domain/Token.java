package com.greentree.model.domain;

import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.ArrayList;
import java.util.Date;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.persistence.Column;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.Entity;

// http://www.baeldung.com/hibernate-mappingexception-unknown-entity
// import org.hibernate.annotations.Entity;

import org.apache.commons.codec.binary.Base64;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import javax.persistence.Transient;

/**
 * <code>Token</code> objects are used to validate <code>{@link Claim}</code>
 * objects, which grant access to data contained in <code>{@link Block}</code>
 * objects. Much of the code for this class comes from marilena.panagiotidou and
 * is available here: <a href="https://www.mkyong.com/java/
 * java-asymmetric-cryptography-example/">Java â€“ Asymmetric Cryptography
 * example</a>.
 *
 * @author david5MX53G
 */
@Entity
@Table(name="Token")
public class Token implements Serializable {    
    /** 
     * {@link org.apache.logging.log4j.Logger} is for logging logs to the log
     */
    @Transient
    protected static final Logger LOG = LogManager.getLogger();

    /**
     * generated by Eclipse ID for implementing {@link Serializable}.
     */
    @Transient
    private static final long serialVersionUID = -6888536819846215415L;

    /**
     * This is used by {@link Token#encrypt(java.lang.String)} to encrypt data 
     * which can be later de-crypted using {@link Token#privateKey}.
     *
     * TODO: make these private!
     */
    @Column(name="publicKey")
    RSAPublicKey publicKey;
    
    /**
     * This is used to look up the {@link Token} instance by its 
     * {@link Token#publicKey} in storage (e.g., storage or system file).
     */
    @Id
    @Column(name="keyId")
    String keyId;
    /** 
     * NOTE: "The @Column annotation is purely optional, and is there to let 
     * you override the auto-generated column name." (skaffman, 2011, 
     * https://stackoverflow.com/questions/4662582/make-hibernate-ignore-class-variables-that-are-not-mapped)
     */
    
    /**
     * This is used by {@link Token#checkPassphrase(java.lang.String)}, among 
     * other things.
     */
    @Column(name="privateKey")
    RSAPrivateKey privateKey;
    
    /** 
     * This uniquely identifies the {@link Token} instance in the database for 
     * {@link org.hibernate}
     */
    @Transient
    private Integer id;

    /**
     * This is used by {@link Token#checkPassphrase(java.lang.String) 
     */
    @Column(name="passphrase")
    private String passphrase;

    /**
     * This stores all {@link Block} objects issued by this {@link Token}.
     */
    @Column(name="blockChain")
    private ArrayList<Block> blockChain = new ArrayList<>();
    
    /**
     * This default constructor is used by Hibernate.
     */
    public Token() {}

    /**
     * Creates a new <code>Token</code> instance with a 2048-bit RSA
     * <code>{@link KeyPair}</code>, secret <code>passphrase</code> with which
     * to validate users, and <code>{@link Cipher}</code> to decrypt ciphertext
     * sent to this object via <code>{@link PublicKey}</code> cryptography.
     *
     * @param passphrase keep it secret; keep it safe
     */
    public Token(String passphrase) {
        this.passphrase = passphrase;
        LOG.debug("passphrase = " + passphrase);
        
        KeyPairGenerator keyGen;
        try {
            keyGen = KeyPairGenerator.getInstance("RSA");
            keyGen.initialize(2048);
            KeyPair pair = keyGen.genKeyPair();
            LOG.debug("keyPair: " + pair.toString());
            
            this.privateKey = (RSAPrivateKey) pair.getPrivate();
            LOG.debug("privateKey: " + privateKey.toString());

            this.publicKey = (RSAPublicKey) pair.getPublic();
            LOG.debug("publicKey: " + publicKey.getAlgorithm());
        } catch (NoSuchAlgorithmException e) {
            LOG.error("keyGen = KeyPairGenerator.getInstance(\"RSA\");" 
                + e.getClass().getSimpleName() + ": " + e.getMessage());
        }
        
        String tempId = String.valueOf(
            this.publicKey.getModulus()
        );
        
        this.keyId = tempId.substring(0, 9)
            + tempId.substring(tempId.length()-9);
        LOG.debug("keyId: " + this.keyId);
        
        String msg = "token instantiated at " + new Date().toString();
        this.blockChain.add(Block.ROOT);
        this.addBlock(msg, this.encrypt(this.passphrase));
        LOG.debug(msg);
    }

    /**
     * This method is used to look up {@link com.greentree.model.domain.Token}
     * objects in the database.
     * @return {@link String} derived from the modulus of the 
     * {@link Token#publicKey}
     */
    public String getKeyId() {
        return this.keyId;
    }
    
    /** 
     * getter for {@link Token#id}
     * @return 
     */
    public Integer getId() {
        return this.id;
    } 
    
    /**
     * This sets the {@link Token#id} value.
     * 
     * @param id {@link Integer} which will be the new id.
     */
    public void setId(Integer id) {
        this.id = id;
    }

    /**
     * @return <code>{@link ArrayList}</code> of <code>{@link Block}</code>
     * objects issued by this
     */
    public ArrayList<Block> getBlockChain() {
        return this.blockChain;
    }

    /**
     * Adds a new {@link Block} to the <code>{@link Token#blockChain}</code>.
     *
     * @param msg {@link String} to be stored in a new
     * <code>{@link Block}</code> in the <code>
     *     blockChain</code> of this {@link Token}
     * @param pass {@link String} should be encrypted with the
     * {@link RSAPublicKey} of this <code>
     *     Token</code> and return true from {@link Token#checkPassphrase(String)}
     */
    public void addBlock(String msg, String pass) {
        if (this.checkPassphrase(pass)) {
            this.blockChain.add(
                new Block(msg, this.blockChain.get(this.blockChain.size() - 1), this)
            );
        }
    }

    /**
     * Returns the <code>PublicKey</code> of the <code>Token</code>. This is
     * used to send securely encrypted <code>String</code> objects back to the
     * <code>Token</code> for validation against the <code>Token</code>
     * passphrase.
     *
     * @return RSAPublicKey used for sending encrypted messages which only this
     * object can decrypt
     */
    public RSAPublicKey getPublicKey() {
        return this.publicKey;
    }

    /**
     * Returns the input encrypted by this <code>{@link Token#publicKey}</code>.
     *
     * @param plaintext to be encrypted with the <code>RSAPublicKey</code> of
     * this <code>Token
     * </code>
     * @return input encrypted by this <code>{@link Token#publicKey}</code>
     */
    public String encrypt(String plaintext) {
        Cipher cipher;
        String ciphertext = null;
        try {
            cipher = Cipher.getInstance("RSA");
            cipher.init(Cipher.ENCRYPT_MODE, this.getPublicKey());
            ciphertext = Base64.encodeBase64String(cipher.doFinal(plaintext.getBytes("UTF-8")));
        } catch (NoSuchAlgorithmException | NoSuchPaddingException 
            | InvalidKeyException | IllegalBlockSizeException 
            | BadPaddingException | UnsupportedEncodingException e) {
            LOG.error("String encrypt(" + plaintext + ") " 
                + e.getClass().getName() + " " + e.getMessage());
        }
        return ciphertext;
    }

    /**
     * Confirms whether the given <code>{@link Token}</code> has the same value
     * as this. The method should only return true if both variables refer to
     * the same object because each <code>Token
     * </code> is initialized with a unique <code>{@link KeyPair}</code>.
     *
     * @param other will be compared with this <code>Token</code> based on the
     * Base64-encoded <code>{@link RSAPublicKey}</code> values of each
     * @return true when the given <code>Token</code> has the same value as this
     * <code>Token</code>
     */
    public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof Token) {
            Token that = (Token) other;
            if (Base64.encodeBase64String(this.getPublicKey().getEncoded()).equals(Base64.encodeBase64String(that.getPublicKey().getEncoded()))) {
                result = true;
            }
        }
        return result;
    }

    @Override
    public int hashCode() {
        return this.getPublicKey().getModulus().hashCode();
    }

    @Override
    public String toString() {
        String blocks = String.valueOf(this.blockChain.size());
        Integer pass = this.passphrase.length();
        String publicKey = this.publicKey.toString();
        String privateKey = this.privateKey.toString();

        return "blocks: " + blocks + "\n"
            + "passphrase: " + pass + "\n"
            + "publicKey: " + publicKey + "\n"
            + "privateKey: " + privateKey + "\n";
    }

    /**
     * Decrypts the given ciphertext <code>String</code> using the private key
     * of the object, then checks the resulting plaintext against the passphrase
     * and returns true or false.
     *
     * @param ciphertext to be decrypted
     * @return true, if ciphertext matches the passphrase of this
     * <code>{@link Token}</code>
     */
    public Boolean checkPassphrase(String ciphertext) {
        try {
            Cipher cipher;
            String plaintext = null;
            try {
                cipher = Cipher.getInstance("RSA");
                cipher.init(Cipher.DECRYPT_MODE, this.privateKey);
                plaintext = new String(cipher.doFinal(Base64.decodeBase64(ciphertext)), "UTF-8");
            } catch (NoSuchAlgorithmException e) {
                LOG.debug(
                    "NoSuchAlgorithmException on getting RSA cipher instance: " + e.getMessage()
                );
            } catch (NoSuchPaddingException e) {
                LOG.debug(
                    "NoSuchPaddingException on getting RSA cipher instance: " + e.getMessage()
                );
            }

            if (plaintext.equals(this.passphrase)) {
                return true;
            } else {
                return false;
            }
        } catch (InvalidKeyException | UnsupportedEncodingException
            | IllegalBlockSizeException | BadPaddingException e) {
            LOG.debug(e.getMessage());
            return false;
        }
    }

    /**
     * Encrypts the passphrase using the public key of the <code>Token</code>,
     * decrypts the <code>
     * Token</code> with the corresponding private key, and returns true, if the
     * decrypted text matches the passphrase. This simulates the process of a
     * <code>User</code> sending the encrypted passphrase to the
     * <code>Token</code> for validation, ensuring the <code>Token
     * </code> is in good working order.
     *
     * @return True if the <code>Token</code> is able to encrypt and decrypt its
     * passphrase
     */
    public boolean validate() {
        if (this.publicKey == null | this.privateKey == null | this.passphrase == null
            | this.blockChain == null | this.keyId == null) {
            return false;
        }

        else return this.checkPassphrase(this.encrypt(this.passphrase));
    }

    /**
     * adds a <code>Block</code> to this {@link Token#blockChain}, granting
     * access to some other <code>Token</code> per the given <code>Claim</code>.
     *
     * @param data {@link String} stored in the new {@link Block} and accessible
     * only to the given
     * <cide>claim</code>
     * @param ciphertext {@link String} encrypted with the
     * {@link Token#publicKey} of this object
     * @param claim {@link Claim} specifying some other {@link Token} that is
     * allowed read access on the new <code>Block</code>
     */
    public void addBlock(String data, String ciphertext, Claim claim) {
        if (this.checkPassphrase(ciphertext)) {
            Block block = new Block(data, this.blockChain.get(this.blockChain.size() - 1), this);
            block.addClaim(claim, ciphertext);
            this.blockChain.add(block);
        }
    }
}
