package com.greentree.model.domain;

import java.io.Serializable;
import java.security.MessageDigest;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.TreeSet;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * A <code>Block</code> may be created, not modified. It is created by a
 * <code>User</code>, and only a <code>User</code> with a <code>Claim</code>
 * issued by the creator may read the <code>
 * Block</code>. The purpose of reading a <code>Block</code> is to see the
 * <code>message</code> it contains. Credit for significant portions of this
 * code is due to Kass for <a href=
 * "https://tinyurl.com/y7tuzl77">Creating Your First Blockchain with Java. Part
 * 1.</a>
 *
 * @author david5MX53G
 * @see com.greentree.model.domain.User
 * @see com.greentree.model.domain.Claim
 */
public class Block implements Serializable, Comparable {
    /** 
     * {@link org.apache.logging.log4j.Logger} is for logging logs to the log
     */
    Logger logger = LogManager.getLogger();

    /** <code>Array</code> of <code>{@link Claim}</code> objects which have
     * access to this data.
     */
    private Set<Claim> claimSet;

    /**
     * Arbitrary contents stored in this <code>Block</code> for safety.
     */
    private final String data;

    /**
     * Identifies this <code>{@link Block}</code> object.
     */
    private final String hash;

    /**
     * The <code>{@link Token}</code> which initialized this.
     */
    private final Token issuer;

    /**
     * Identifies the <code>Block</code> from which this one derives its hash.
     */
    private final Block referee;

    /**
     * This is the <code>{@link Block}</code> from which all others derive their
     * hash values.
     */
    public final static Block ROOT = new Block("I am root.");

    /**
     * ID for <code>{@link Serializable}</code>, auto-generated by Eclipse
     */
    private static final long serialVersionUID = -7535994912736400229L;

    /**
     * milliseconds since January 1, 1970, 00:00:00 GMT when this was created.
     */
    private final long timeStamp;

    /**
     * Constructs a new instance of the <code>Block</code> class.
     *
     * @param data secured by this <code>Block</code> from modification and
     * unauthorized access
     * @param referee identifies the <code>Block</code> from which this derives
     * its hash
     * @param issuer <code>Token</code> which can update the
     * <code>Claim[]</code> of this
     */
    public Block(String data, Block referee, Token issuer) {
        this.data = data;
        this.hash = this.hash(data + referee.getHash());
        this.issuer = issuer;
        this.referee = referee;
        this.timeStamp = new Date().getTime();
        this.claimSet = new HashSet<Claim>();
    }

    /**
     * Returns a new <code>Block</code> class. No <code>issuer</code> is
     * defined, so there is no way to get the data of the resulting object. No
     * <code>referee</code> is defined, so there is no assurance the resulting
     * object is trustworthy. This constructor is useful only for starting a new
     * <code>Block</code> chain.
     *
     * @param data secured by this <code>Block</code> from modification and
     * unauthorized access
     */
    private Block(String data) {
        this.data = data;
        this.hash = this.hash(data);
        this.issuer = null;
        this.referee = null;
        this.timeStamp = new Date().getTime();
    }

    /**
     * Returns the data of this {@link Block}, if the requesting
     * <code>Token</code> has a valid <code>
     * Claim</code> in the <code>Set<Claim></code> of this <code>Block</code>
     * and the <code>passphrase</code> is valid for the requester.
     *
     * @param requester {@link Token} identifies the <code>Token</code> to look
     * for in the {@link
     *     Set}<<code>Claim</code>> of this <code>Block</code>
     * @param passphrase {@link String} must be encrypted and <code>true</code>
     * for the <code>
     *     {@link Token#checkPassphrase (String)}</code> of the given
     * <code>Token</code>
     * @return data {@link String} returned if the <code>Token</code> is found
     * in the <code>Set
     * <Claim></code> of non-expired <code>Claim</code> objects and the
     * <code>passphrase</code> is valid for the requester
     */
    public String getData(Token requester, String passphrase) {
        String data = null;
        Long now = new Date().getTime();
        if (!this.equals(ROOT)) {
            if (requester.checkPassphrase((passphrase))) {
                // does this requester exist for any valid Claim in the Set?
                Iterator<Claim> it = claimSet.iterator();
                Claim claim;
                while (it.hasNext()) {
                    claim = it.next();
                    if (claim.getNotBefore() < now & claim.getExpirationTime() > now) {
                        if (claim.getToken().equals(requester)) {
                            data = this.data;
                            break;
                        }
                    }
                }
            }
        }
        return data;
    }

    /**
     * @return this SHA-256 hash <code>String</code> value
     */
    public String getHash() {
        return this.hash;
    }

    /**
     * @return <code>{@link Token}</code> which initialized this
     */
    public Token getIssuer() {
        return this.issuer;
    }

    /**
     * @return unique signature of the parent <code>Block</code> for this object
     */
    public Block getReferee() {
        return this.referee;
    }

    /**
     * @return this SHA-256 hash <code>String</code> value
     */
    public Long getTimeStamp() {
        return this.timeStamp;
    }

    /**
     * Checks the given <code>Block</code> to see if it is the same as this.
     * They are the same when they share the same SHA-256 {@link MessageDigest}
     * <code>String</code>.
     *
     * @param block to be checked for equality with this
     * @return true, if the given <code>Block</code> equals this
     */
    @Override
    public boolean equals(Object other) {
        boolean result = false;
        if (other instanceof Block) {
            Block that = (Block) other;
            if (this.hash.equals(that.getHash())) {
                result = true;
            }
        }
        return result;
    }

    /**
     * @return integer version of <code>{@link Block#getHash()}</code>
     */
    @Override
    public int hashCode() {
        return this.hash.hashCode();
    }

    /**
     * @return <code>{@link String}</code> value representing this
     * <code>Block</code>
     */
    @Override
    public String toString() {
        String claims;
        if (this.claimSet == null) {
            claims = "0";
        } else {
            claims = String.valueOf(this.claimSet.size());
        };

        String issuer;
        if (this.issuer == null) {
            issuer = "none";
        } else {
            issuer = String.valueOf(this.issuer.hashCode());
        }

        String referee;
        if (this.referee == null) {
            referee = "none";
        } else {
            referee = this.referee.getHash();
        }

        String str = "ROOT: " + Block.ROOT.getHash() + "\n"
            + "claims: " + claims + "\n"
            + "hash: " + this.hash + "\n"
            + "issuer: " + issuer + "\n"
            + "referee: " + referee + "\n"
            + "timestamp: " + String.valueOf(this.timeStamp);
        return str;
    }

    /**
     * @return true, if this <code>Block</code> is in working order.
     */
    public boolean validate() {
        if (this.equals(ROOT)) {
            return true;
        } else {
            if (this.hash == null) {
                return false;
            }
            if (this.referee == null) {
                return false;
            }
            if (this.data == null) {
                return false;
            }
            if (this.timeStamp > new Date().getTime()) {
                return false;
            }
            if (this.claimSet == null) {
                return false;
            }
            return true;
        }
    }

    /**
     * Adds a <code>{@link Claim}</code> to this such that the
     * <code>{@link Token}</code> in the <code>Claim</code> can access the the
     * data in this object. Note that ROOT has no issuer, and the data is
     * public, so checking the passphrase is both unnecessary and impossible.
     *
     * @param claim added to the <code>{@link Set}</code> of <code>Claim</code>
     * objects allowed access to the <code>data</code> of this object.
     * @param passphrase must successfully validate against the
     * <code>issuer</code> for this <code>
     * Block</code>
     */
    public void addClaim(Claim claim, String passphrase) {
        if (this.equals(ROOT)) {
            return;
        } else if (this.issuer.checkPassphrase(passphrase)) {
            claimSet.add(claim);
        }
    }

    /**
     * @return SHA-256 digest of the given input <code>String</code>
     */
    private String hash(String input) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(input.getBytes("UTF-8"));
            StringBuffer hexString = new StringBuffer();
            for (int i = 0; i < hash.length; i++) {
                String hex = Integer.toHexString(0xff & hash[i]);
                if (hex.length() == 1) {
                    hexString.append('0');
                }
                hexString.append(hex);
            }
            return hexString.toString();
        } catch (Exception e) {
            logger.error(e.getMessage());
            throw new RuntimeException(e);
        }
    }

    /** 
     * 
     * @param o the {@link Block} which is either less than, equal, or greater 
     * than this
     * @return "-1" if the given <code>Block</code> is among the set of those to
     *  which this refers as a {@link Block#referee); "0" if the given <code>
     * Block</code> is this; "1" if neither -1 nor 0 are true
     */
    @Override
    public int compareTo(Object o) {
        int result;
        Block that = (Block) o;
        logger.debug("This Block: " + this.getHash());
        logger.debug("Parameter Block: " + that.getHash());
        
        if (this.equals(that)) {
            result = 0;
            logger.debug("The Blocks are the same.");
        } else {
            HashSet<Block> referees = new HashSet<>();
            Block current = this.getReferee();
            while (!current.equals(Block.ROOT)) {
                referees.add(current);
                current = current.getReferee();
            }
            
            referees.add(current);
            logger.debug(
                "This Block has " + String.valueOf(referees.size()) 
                    + " referees"
            );
            
            if (referees.contains(that)) {
                result = -1;
                logger.debug(
                    "Parameter Block is among the set of Blocks to which this "
                        + "Block refers."
                );
            } else {
                result = 1;
                logger.debug(
                    "Parameter Block is not among the set of Blocks to which "
                        + "this Block refers."
                );
            }
        }
        return result;
    }
}
